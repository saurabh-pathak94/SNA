
# The script generates ROC points by taking different amounts of best predicted edges from the predicted edge set
# that was generated by using logistic regression that in turn had input from a group of vertex similarity measures.

glmScore <- function(originalGraph, sampledGraph, minConnectionsToAdd, maxConnectionsToAdd, step)
{
	options(error=recover)
	
	
	source("glmTrainAndPredict.R")
	source("plotRoc.R")
	source("glmSimList.R")
	
	
	actual_edgeList <- get.edgelist(originalGraph)
	nodeCount <- max(actual_edgeList) + 1
	potentialConnections <- nodeCount * (nodeCount - 1) / 2
	
	
	
	predictions <- glmTrainAndPredict(sampledGraph)
	
	
	
	list <- glmSimList(sampledGraph, predictions) 	# sort glm predictions by their strength
	
	
	treshold <- 0
	
	
	
	maxi <- min(maxConnectionsToAdd, potentialConnections, nrow(list))
	numOutRows <- (maxi - minConnectionsToAdd) / step + 1
	rocPoints <- mat.or.vec(numOutRows, 2)

	i <- minConnectionsToAdd
	i_out <- 1


	while (i_out <= numOutRows)
	{
		numBestToTake <- i


		predictedGraph <- predictLinks(sampledGraph, list, numBestToTake, treshold)
		rocr <- roc(originalGraph, sampledGraph, predictedGraph)


		rocPoints[i_out, 1] = rocr[2]		#fpr as x
		rocPoints[i_out, 2] = rocr[1]		#tpr as y

		i <- i + step
		i_out <- i_out + 1

	} 	# for (i in 1:potentialConnections)
	
	
	rocPoints
	

}
